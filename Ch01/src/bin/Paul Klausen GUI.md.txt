Swing 

3-и класи, які варто знати: 

1. `SwingUtilities` містить багато статичних методів та утилі, наприклад, `invokeLater()` і `invokeAndWait()`, щоб переконатись, що код виконується в потоці виконання event dispatch.
2. `SwingConstants` - місце для збереження констант, які використовуються в більшості компонентів.
3. Абстрактний клас `SwingWorker`, який використовується для операцій GUI, яким  потрібен час для виконання і один чи декілька потоки виконання.


The Sans Mono (font Oreilly), -> Inconsolata, Source Code Pro, Input Mono, Hack, Inconsolata-g, losevka, Monoid, Bitstream Vera Sans Mono, SF Mono, Fira Code, Roboto Mono, Ubuntu Mono, Terminus, Code New Roman, Consolas

(slant.co/options/269/alternatives/~fantasque-sans-mono-alternatives)


Icons: Font Awesome, Foundation Icon Fonts, Ionicons, Material Design Icons, Octicons, Typicons)





Java 2

Приклад HelloSwing (10-13)

Приклад складається з вікна прямокутної форми, в яке вставлені компоненти: поле вводу (`JTextField`), дві кнопки (`JButton`) і список (`JList`). Всі компоненти є класами Swing. Всі компоненти, крім списку, зразу ініціалізовані. Клас має конструктор, який:

* визначає текст для заголовка вікна;
* розмір вікна при відкритті додатку;
* визначає, що програма повинна бути закрита, коли користувач натисне на кнопку закриття вікна;
* виклик методу `addListeners()`, що призначає функціональність для кнопок у вікні;
* виклик методу `createWindow()` розміщує компоненти у вікні;
* визначаємо, що вікно повинно відображатись на екрані.

Екземпляр типу `DefaultListModel` визначає просту модель для списку.

Клас також має метод `createLabel()`, який створює порожній надпис (`JLabel`), в даному випадку компонент використовується як заповнювач місця, який визначається `setPreferredSize()`.

Вікно (`JFrame`) по-замовчуванню використовує макет `BorderLayout`, який ділить вікно на 5-ть частин:

* Північ (`NORTH`) - має однакову ширину з вікном і висоту, яка визначається висотою компонента, що в ньому знаходиться, аналогічно працює і Південь (`SOUTH`)
* Захід (`WEST`) - висота визначається висотою вікна за мінусом `SOUTH` і `NORTH` частин, ширина визначається по ширині компонента, який в нього вставлений, аналогічно діє і Схід `EAST`
* `CENTER` - центральна частина вікна.

Кожна частина може містити тільки один компонент, тобто `BorderLayout` може тільки мати 5-ть компонентів. Якщо якась частина не містить компонент, то вона згортається і не використовується.

Метод `createWindow()` розміщує прожній надпис в усіх чотирьох сторін (`NORTH`, `SOUTH`, `WEST` і `EAST`), щоб створити поле відступу в `10px`. `JPanel`, який також має макет `BorderLayout`, північну, центральну та південу частину заповнює вміст згенерований методами `createTop()`, `createCenter()`, `createBottom()`, відповідно.

Метод `createTop()` створює компоненти для верхньої частини вікна. Компонент `JPanel` з надписом зліва, кнопкою зправа і вводом тексту по центру. Центральна частина завжди вся заповнюється, тому поле вводу завжди заповнює всю панель, що не використовують два інших компоненти і регулюється шириною вікна. Для встановлення відступів між компонентами в конструкторі зазначаємо параметрами по ширині та висоті: `new JPanel(new BorderLayout(10, 10));`

Метод `createBottom()` створює компонент `JPanel` з макетом `FlowLayout`, який контролює потік розміщення елементів по горизонталі. В даному випадку вирівнювання встановлено по правому краю. В панель додаємо кнопку для очищення вмісту списку. Кнопка буде відображатися в правому нижньому куті вікна. 

Метод `createCenter()` створює список. До списку потрібно призначити модель даних (об'єкт типу `DefaultListModel`), який мусить містити дані для відображення. Метод створює компонент `JPanel` з макетом `BorderLayout` та призначає порожні надписи до `NORTH` та `SOUTH` частин для створення відступів з верху та з низу. Коли список додається до панелі, він інкапсулюється в компонент `JScrollPane`, який дозволяє перемотувати вміст.

Після створення вікна додаємо функціональність до двох кнопок. Коли користувач натискає кнопку, виникає подія. Конкретно це означає, що інші об'єкти можуть реєструватися як слухачі до цієї події, вказавши метод з підписом. Цей метод називається обробником подій. Після натискання кнопки він перевірить чи є слухач і якщо так, він викличе цього слухача. Передається повідомлення слухачам об'єктів, що повідомляє про натискання кнопки і слухач може щось виконати.

В прикладі є визначений внутрішній клас, який є простим класом в межах іншого класу. Він називається `AddAction` і реалізує функціональний інтерфейс `ActionListener`, який має один метод `actionPerformed()` і є прикладом обробника подій. Він повинен бути пов'язаний з кнопкою `Add` методом `addActionListener()`. Обробник подій дістає текст з полем вводу, і якщо текст не прожній, обробник оновлює модель списку з новим текстом. В результаті введене ім'я відображається в списку. Потім вміст поля вводу видаляється і полю ввода задається фокус, і поле вводу знову готове до введення нового імені. Клас `AddAction` реалізує інтерфейс `ActionListener`, це означа, що об'єкт типу `AddAction` може використовуватись як об'єкт слухача кнопки:


```java
cmdAdd.addActionListener(new AddAction());
```

Зверніть увагу, що `actionPerformed()` може посилатись до екземпляра змінних головного класу ХХХ, це можливо, тому що `AddAction` є внутрішнім класом.

Друга кнопка працює аналогічно, проте обробник подій реалізований як анонімний клас, в методі `actionPerformed()` якого очищається модель списку.

Зараз вікно завершене, проте це не програма. Для запуску програми її слід ініціювати об'єктом типу `MainWindow` і це повинна бути головна програма:

```java
public static void main(String[] args) {
    new MainWindow();
}
```

Удосконалення HelloSwing

З прикладу видалимо всі методи `createLabel()`, щоб прибрати відступи і встановити їх по іншому:

```java
panel.setLayout(new BorderLayout(10, 10);
panel.setBorder(new EmptyBorder(10, 10, 10, 10));
```

Додамо в нижню частину ще одну кнопку і встановимо її розмір вручну:

```java
cmdAnt.setPreferredSize(new Dimension(80, 27));
```

аналогічний розмір встановимо і для кнопки `clear`.

Додамо внутрішній клас `CountAction` для обробки подій. Обробник подій виконає статичний метод `JOptionPane.showMessageDialog()`, який відкриє вікно з повідомленням. Метод має 4-ри параметри (тільки 2-а є обов'язковими). Перший визначає власника вікна, наступний відображає текст, третій - текст в заголовці вікна, останній - іконку у вікні повідомлення.

Також модифікуємо обробник кнопки "Clear", щоб випадково не очистити повідомлення насупним чином:

```java
if(JOptionPane.showConfirmDialog(MainWindow.this, "Are you sure you want to delete the list?", "warning", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION)
    model.clear();
```

Приклад Calculator

button.setFont(new Font("Liberation Sherif", Font.PLAIN, 16));
button.setMargin(new Insets(0, 0, 0, 0);

new GridLayout(1, 2, 10, 0) - макет, який ділить макет на число рядків і колонок, які мають секції однакового розміру. В цьому прикладі в нас є один рядок з двома стовпчиками і результат буде складатися з двох секцій, які завжди будуть однакового розміру, два поля вводу додаються до панелі і кожне поле автоматично заповнить секцію. Конструктор `GridLayout` має два додаткові параметри, які вказують скільки місця для відступів ма бути між секціями по горизонталі та вертикалі.

3 Шрифти і кольори

Приклад TextColor (29-30)

Метод `createLabel()` містить 6-ть параметрів:

* текст;
* колір фону, який представлений об'єктом типу `Color` (приймає цілі числа від 0-255 в R, G, B);
* колір тексту, який представлений об'єктом типу `Color`;
* шрифт - текст представлений об'єктом типу `Font`, який визначає назву шрифта, стиль (`FONT.PLAIN`, `FONT.ITALIC`, `FONT.BOLD`) та розмір;
* ширину і
* висоту

Компонент `JLabel`, по-замовчуванню має прозорий фон, для його відключення використовуємо метод `setOpaque(true)`.

Особливості мактеу `BorderLayout`:
* `NORTH` - ширина визначається шириною панелі. Висота визначається висотою компонента, яка визначена в методі `setPreferredSize()`, проте ширина з попереднього метода ігнорується;
* `WEST` - висота є висотою панелі мінус висота, що використовується для `NORTH` і `SOUTH`. Ширина визначається шириною компонента, визначеною в методі `setPreferredSize()`, проте висота з цього метода ігнорується.
* `EAST` - висота є висотою панелі мінус висота, що використовується для `NORTH` і `SOUTH`. Ширина визначається шириною компонента, визначеною в методі `setPreferredSize()`, проте висота з цього метода ігнорується.
* `CENTER` - ширина і висота панелі мінус ширина, що використовується у `WEST` та `EAST`. Висота рівна висоті панелі мінус висота, що використовується в `NORTH` і `SOUTH`. Метод `setPreferredSize()` - ігнорується.

Вираз `setLocationRelativeTo(null)` змусить вікно відкритись по середині екрану.



2.4 Діалогові вікна


```
            MainView
            btn EnterName -> EnterView
ShowView <- btn OpenList
```

Програма `Dialogs` створює головне вікно (`JFrame`) і дві кнопки, при натисканні на першу відкривається модальне вікно (блокує основне вікно) діалогу (`JDialog`), в яке можна ввести ім'я та прізвище. При натисненні на другу кнопку відкривається не модальне вікно (не блокує основне вікно) з відображенням списку введених імен та прізвищ. Вінка між собою мають зв`язок, наприклад, при введені даних імені та прізвище в діалог `EnterView`, вони одразу ж будуть відображатись у `ShowView`.

Приклад також використовує клас `Name` як `POJO` для імені та прізвища.

Приклад `EnterView` (35-38)

Клас успадковується від `JDialog` та має 3-ри екземпляри змінних:

* дві для вводу тексту
* і модель для списку, що буде відображатись в іншому вікні діалога.

Модель передається через конструктор і тому може пов'язувати різні діалогові вікна. Також в конструктор `JDialog` передається параметр `Dialog.ModalityType.APPLICATION_MODAL`, який вказує на модальність вікна. Вираз `setDefaultCloseOperation(DISPOSE_ON_CLOSE)` визначає, шо при закритті діалогового вікна, основна програма не буде завершена.

Метод `createView()` ініціалізує компоненти вікна (див. попередні приклади, які описують нюанси композиції елементів). Кнопки використовують обробники подій, які підключені посиланням на метод (`method reference`), в попередніх прикладах показано підключенням внутрішнього класу (потрібно писати багато коду) і анонімного класу (важко читати). Кнопка закриття вікна викликає метод `dispose()` для закриття діалогу. Друга кнопка копіює значення з полів вводу, створюючи об'єкт `Name` і додає до моделі даних. Якщо текстові поля порожні показує діалог з описом помилки.

Приклад `ShowView` (40-41)

Цей клас також успадкований від `JDialog`. Діалогове вікно містить модель даних і слухач. Оскільки діалогове вікно відкривається з головного вікна і воно не є модальним (`Dialog.ModalityType.MODELESS`), його можна відкривати багато разів з головного вікна. В даному прикладі ми це не дозволимо робити). Проте після закриття вікна його потрібно знову відкрити. Тому необхідно повернути повідомлення до головного вікна, коли діалогове вікно закрите. Для цього в конструкторі є параметр `listener` типу `CloseListener`. `CloseListener` - це інтерфейс, який визначений в файлі `MainView` і має один метод, який викликається при закритті діалогового вікна. При натиску на кнопку `Close` він спрацьовує. Проте діалогове вікно можна закрити настиснувши кнопку закриття на панелі вікна. Для цього використовуємо `WindowEvent` і можна виконати в різних контекстах, але в цьому випадку використовуємо клас `CloseHandler`, який  асоціюється в конструкторі з діалоговим вікном. 

Приклад `MainView` (43-44)

Клас ініціює модель даних для списку і кнопку. Модель надсилається до обох діалогових вікон і кнопка використовується для відкриття діалогового вікна списку. Клас також реалізує інтерфейс `CloseListener` і реалізує метод `dialogClose()`. Коли діалогове вікно з списком відкривається, відбуваються дві речі:

1. Відключається кнопка, що відкрила діалог зі списком, щоб унеможливити повторне відкриття діалогу;
2. Діалоговому вікну надсилається модель для відображення списку і посилання на головне вікно, через яке при закритті діалогу можна викликати метод `dialogClose()`, щоб знову активувати кнопку відкриття діалогового вікна зі списком;

Приклад поліпшення попереднього додатку

Щоб поліпшити додаток додамо кнопу і при подвійному натисканні на елементі списка мати можливість відредагувати збережені дані в `EnterView`. До класу `Name` додамо `setters` до двох текстових полів імені та прізвища. Також додамо параметр `index` до конструктору `EnterView`:

```java
public EnterView(DefaultListModel model, int index);
```

Якщо `index` негативний, значить створюється новий `Name`, інакше - редагується об'єкт по індексу з моделі даних.

Потрібно також додати внутрішній клас до `ShowView` (45-46)

??? Додамо даний слухач до методу `createView` (46)

??? Коли ви зробите ці зміни, ви побачите, що список не оновлюється, а закривається діалогове вікно `ShowView` і знову відкривається з оновленим вмістом. Для вирішення цієї проблеми ви маєте додати наступний клас до головного класу:

???ПРИКЛАД ст46

Цей клас розширює `DefaultListModel` новим методом. Ви також повинні змінити визначення моделі в `MainView`:

```java
private DefaultListModel = new EnhancedListModel();
```

Новий метод моделі повинен викликатись в обробнику подій `ok()` в класі `EveentView` після того як об'єкт був оновлений:

```java
((EnhancedListModel) model).update(index);
```

!!! Зверніть увагу, на приведення типів. Після цього список буде оновлюватись коректно.

Ви маєте додати ще одне покращення в діалог `EnterView`. Потрібно додати кнопку, що буде використовуватись для видалення елементу під час редагування, проте кнопка повинна бути доступна тільки в діалозі під час редагування `Name`.

2.5 Більше компонентів

Приклад відображує форматований текст. Приклад містить багато компонентів, має складний макет і зручний менеджер обробки подій.

МАЛ48

Приклад використовує вибір шрифту для малювання тексту, вирівнювання тексту (лівору, праворуч і по центру), вибір кольору для тексту, вибір фону для тексту.

Крім компонентів `JLabel`, `JTextField`, в прикладі використовуються наступні компоненти:

* `JComboBox` - список об'єктів, з яких можна вибрати один варіант;
* `JCheckBox` - простий компонент з списком об'єктів, де ви вибираєте властивість;
* `JSlider` - компонент, який дозволяє вибрати значення з діапазону.

Приклад має складний макет, який використовує:

* `BorderLayout`;
* `FlowLayout`;
* `GridLayout`;

СТОР50 Метод `createWindow()` - використовує макет `BorderLayout` з полями і ділить вікно на дві частини:

* у верхній знаходиться панель з усіма компонентами для редагування тексту,
* знизу відображається відредагований текст.

Нижню панель представляє компонент `JLabel`:

```java
private JLabel lblText = new JLabel("");
```

СТОР 50 Нижня панель створюється методом `createCenter()`:


```
panel[BorderLayout + EmptyBorder(20, 0, 20, 0)]
     sing[BorderLayout + LineBorderBlack]
         inner[BorderLayout(NORTH - крапки, SOUTH - крапки, EAST - поле, WEST - поле)] + LineBorder (white 5px)
              label(center) білий непрозорий фон
```

СТОР 51 Приклади методів `createMargin()` `createDots()` `createDot()`




























